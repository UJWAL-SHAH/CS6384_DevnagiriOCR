# -*- coding: utf-8 -*-
"""CV_Project_Devanagiri_OCR_Other_Models.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yyyJpRPIuhcW1F94vwANuXBH0zzO54nu

This Project is the Group Submission for the subject: Computer Vision

The Group Members:


1.   Prabhleen Saini (PXS210087)
2.   Sai Pratyush Varma P (SXP220013)
3. Ujwal Shah (USS220000)

Link for the Dataset: [UCI Machine Learning](https://archive.ics.uci.edu/ml/datasets/Devanagari+Handwritten+Character+Dataset)

##Data Preparation
"""

#Loading the libraries

import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import tensorflow as tf
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense, Conv2D, MaxPooling2D, Dropout, Flatten
from tensorflow.keras.datasets import cifar10
from tensorflow.keras.utils import to_categorical
from matplotlib.ticker import (MultipleLocator, FormatStrFormatter)
from dataclasses import dataclass
import time
import pandas as pd
import zipfile
import requests
from io import BytesIO

#Loading the file from UCI directory

url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/00389/DevanagariHandwrittenCharacterDataset.zip'
r = requests.get(url)
z = zipfile.ZipFile(BytesIO(r.content))

with z as zip_ref:
    # loop over all files in the zip file
    for member in zip_ref.namelist():
        # extract the file to the current directory
        zip_ref.extract(member, path='.')

"""###Converting the files from Images to CSV"""

#Cleaning the variables
del member
del r
del url
del z
del zip_ref

#Segregating Train Dataset

import os
import csv
from PIL import Image

# specify the path to the root folder
root_path = '/content/DevanagariHandwrittenCharacterDataset/Train'

# create an empty list to store the CSV rows
rows = []
start = 1
end = 32*32

header = ['col{}'.format(i) for i in range(start, end+1)]

# recursively loop over all files and subfolders in the root folder
for foldername, subfolders, filenames in os.walk(root_path):
    for filename in filenames:
        # check if the file is an image (supports .jpg, .png, and .bmp formats)
        if filename.endswith('.jpg') or filename.endswith('.png') or filename.endswith('.bmp'):
            # open the image file using the PIL library
            img = Image.open(os.path.join(foldername, filename))
            
            # convert the image to grayscale and resize to 28x28 pixels
            img_gray = img.convert('L').resize((32, 32))
            
            # get the pixel values of the image and flatten into a 1D list
            pixels = list(img_gray.getdata())
            
            # create a CSV row with the file name and pixel values
            row = [os.path.join(foldername.split("/")[-1])] + pixels
            
            # append the row to the list of CSV rows
            rows.append(row)
            del pixels
            del row
      
# write the CSV file with all rows
with open('Train.csv', 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerow(header)
    writer.writerows(rows)

#Segregating Test Dataset

import os
import csv
from PIL import Image

# specify the path to the root folder
root_path = '/content/DevanagariHandwrittenCharacterDataset/Test'

# create an empty list to store the CSV rows
rows = []

start = 1
end = 32*32

header = ['col{}'.format(i) for i in range(start, end+1)]

# recursively loop over all files and subfolders in the root folder
for foldername, subfolders, filenames in os.walk(root_path):
    for filename in filenames:
        # check if the file is an image (supports .jpg, .png, and .bmp formats)
        if filename.endswith('.jpg') or filename.endswith('.png') or filename.endswith('.bmp'):
            # open the image file using the PIL library
            img = Image.open(os.path.join(foldername, filename))
            
            # convert the image to grayscale and resize to 32*32 pixels
            img_gray = img.convert('L').resize((32, 32))
            
            # get the pixel values of the image and flatten into a 1D list
            pixels = list(img_gray.getdata())
            
            # create a CSV row with the file name and pixel values
            row = [os.path.join(foldername.split("/")[-1])] + pixels
            
            # append the row to the list of CSV rows
            rows.append(row)

# write the CSV file with all rows
with open('Test.csv', 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerow(header)
    writer.writerows(rows)

del rows
del header
del filename
del filenames
del root_path
del foldername
del subfolders

#Loading the data
import pandas as pd

train = pd.read_csv("/content/Train.csv")
train = train.reset_index()

test = pd.read_csv("/content/Test.csv")
test = test.reset_index()

len(train)

len(test)

train.head()

#Just plotting one character

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# extract the first row as a NumPy array
row = train.iloc[:, 1:].iloc[3600].to_numpy()

# define the size of the image
n = 32

# reshape the row into a 2D array of size n*n
image = np.reshape(row, (n, n))

# display the image using Matplotlib
plt.imshow(image, cmap='gray')
plt.show()

"""###Pre-processing of the Data"""

#Normalizing the vlaues
X_train=train.iloc[:, 1:]
X_train=X_train/255

X_test=test.iloc[:, 1:]
X_test=X_test/255

y_train = train.iloc[:, 0]
y_test = test.iloc[:, 0]

!pip install category_encoders

#Encoding the variables

import category_encoders as ce
encoder=ce.OneHotEncoder(handle_unknown='return_nan',return_df=True,use_cat_names=True)
y_train1 = encoder.fit_transform(y_train)
y_test1 = encoder.fit_transform(y_test)

"""##Model No 1 : KNN """

from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import time
#running_times = [model_name, train_time, test_time]
running_times =[]
#evaluation = [model_name, accuracy]
evaluation =[]

knn_clf=KNeighborsClassifier()
train_start_time = time.time()
knn_clf.fit(X_train,y_train1)
train_end_time = time.time() 

y_pred=knn_clf.predict(X_test) #These are the predicted output values
test_end_time = time.time()
running_times.append(["KNN", train_end_time-train_start_time, test_end_time - train_end_time ])
print(running_times)

from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

result1 = classification_report(y_test1, y_pred)
print("Classification Report:")

print (result1)
result2 = accuracy_score(y_test1,y_pred)
print('Accuracy:',result2)
evaluation.append(["knn", result2])

del knn_clf
del corr_matrix

"""## Model No. 2: SVM"""

#Importing the necessary packages and libaries
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn import svm, datasets
import matplotlib.pyplot as plt
import numpy as np

# Import label encoder
from sklearn import preprocessing

# label_encoder object knows how to understand word labels.
label_encoder = preprocessing.LabelEncoder()

# Encode labels in column 'species'.
y_train2= label_encoder.fit_transform(y_train)
#np.unique(y_train2)

y_test2= label_encoder.fit_transform(y_test)
#np.unique(y_test2)

"""### Model No. 2.1: SVM (Kernel = 'Linear')"""

train_start_time = time.time()
linear = svm.SVC(kernel='linear', C=1, decision_function_shape='ovo').fit(X_train, y_train2)
train_end_time = time.time() 
y_pred=linear.predict(X_test) 
test_end_time = time.time()
running_times.append(["Linear SVM", train_end_time-train_start_time, test_end_time - train_end_time ])

running_times

from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

result1 = classification_report(y_test2, y_pred)
print("Classification Report:")

print (result1)
result2 = accuracy_score(y_test2,y_pred)
print('Accuracy:',result2)
evaluation.append(["Linear SVM", result2])

del linear
del y_pred

"""### Model No. 2.2: SVM (Kernel = 'RBF')"""

import time
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
train_start_time = time.time()
rbf = svm.SVC(kernel='rbf', gamma=1, C=1, decision_function_shape='ovo').fit(X_train, y_train2)
train_end_time = time.time() 
y_pred=rbf.predict(X_test) 
test_end_time = time.time()
running_times.append(["rbf", train_end_time-train_start_time, test_end_time - train_end_time ])

result1 = classification_report(y_test2, y_pred)
print("Classification Report:")

print (result1)
result2 = accuracy_score(y_test2,y_pred)
print('Accuracy:',result2)
evaluation.append(["rbf", result2])

"""###Model 2.3: SVM (Kernel = "Poly" with various degrees)"""

from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import train_test_split

from sklearn.metrics import accuracy_score, confusion_matrix

from sklearn import preprocessing
train_start_time = time.time()
grid = {
    'kernel' : ["poly"],
    'degree' : [1,3,5,7],
}
poly  = SVC()
svm_cv = GridSearchCV(poly, grid, cv = 5)
svm_cv.fit(X_train, y_train2)
train_end_time = time.time() 
print("Best Parameters:",svm_cv.best_params_)
print("Train Score:",svm_cv.best_score_)
print("Test Score:",svm_cv.score(X_test,y_test))

y_pred=poly.predict(X_test) 
test_end_time = time.time()
running_times.append(["poly", train_end_time-train_start_time, test_end_time - train_end_time ])

result1 = classification_report(y_test2, y_pred)
print("Classification Report:")

print (result1)
result2 = accuracy_score(y_test2,y_pred)
print('Accuracy:',result2)
evaluation.append(["poly", result2])

"""###Model 2.4: SVM (Kernel = "Sigmoid" with various degrees)"""

train_start_time = time.time()
sig = svm.SVC(kernel='sigmoid', C=1, decision_function_shape='ovo').fit(X_train, y_train2)
train_end_time = time.time() 
y_pred=sig.predict(X_test) 
test_end_time = time.time()

running_times.append(["sigmoid", train_end_time-train_start_time, test_end_time - train_end_time ])
result1 = classification_report(y_test2, y_pred)
print("Classification Report:")

print (result1)
result2 = accuracy_score(y_test2,y_pred)
print('Accuracy:',result2)
evaluation.append(["sigmoid", result2])

print(evaluation)
print(running_times)

"""

---



---



"""